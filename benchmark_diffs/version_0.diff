# Git diff for Version 0
# Unstaged changes compared to HEAD
# Generated: 2026-01-28 11:02:55
# HEAD Commit: d3c5067

diff --git a/trait_ac/src/main.rs b/trait_ac/src/main.rs
index 8b8fa5f..247da56 100644
--- a/trait_ac/src/main.rs
+++ b/trait_ac/src/main.rs
@@ -1,22 +1,23 @@
 use trait_ac::neighborhood::Neighborhood;
 use trait_ac::grid::Grid;
-use trait_ac::rules::{RuleSet, rule_static, rule_average, rule_conway, rule_diffusion, rule_maximum, rule_oscillate, rule_weighted_average, rule_von_neumann};
-use trait_ac::movement::{apply_movement, movement_static, movement_random, movement_gradient, movement_avoid_crowding, movement_trait_based};
-use trait_ac::utils::{print_active_traits, print_statistics, print_separator, semantic_trait_names};
+use trait_ac::rules::{RuleSet, rule_conway};
+use trait_ac::movement::{apply_movement, movement_static};
+use trait_ac::utils::{print_active_traits, print_separator, semantic_trait_names};
+use std::time::Instant;
 
 fn main() {
     println!("=== Modular Cellular Automata Simulation ===\n");
 
     // Configuration
-    let grid_height = 10;
-    let grid_width = 10;
-    let timesteps = 5;
+    let grid_height = 3000;
+    let grid_width = 3000;
+    let timesteps = 100;
 
     // Define which traits are active
     let active_mask = vec![
-        vec![true,  true,  false],  // Traits 0, 1 active
-        vec![false, true,  false],  // Trait 4 active
-        vec![true,  false, false],  // Trait 6 active
+        vec![true,  false, false],  // Traits 0, 1 active
+        vec![false, false, false],  // Trait 4 active
+        vec![false, false, false],  // Trait 6 active
     ];
 
     // True = this neighbor position affects the cell
@@ -44,7 +45,7 @@ fn main() {
     let nbhr_movement_center_col = (nbhr_movement_width-1)/2;
 
     // Initialize grid
-    let mut grid = Grid::new_with_density(grid_width, grid_height, 0.1);
+    let mut grid = Grid::new_with_density(grid_width, grid_height, 1.0);
 
     // Default neighborhood
     let dummy_grid = Grid::new(grid_width, grid_height); // can't use the normal grid because of the lifetime
@@ -74,15 +75,15 @@ fn main() {
     // Create custom rule set
     // Traits: [Energy, Confidence, Cooperation, Aggression, Stability, Mobility, Resource, Age, Adaptability]
     let ruleset = RuleSet::custom([
-        rule_diffusion,    // 0: Energy diffuses
-        rule_average,      // 1: Confidence averages
+        rule_conway,    // 0: Energy diffuses
+        rule_conway,      // 1: Confidence averages
         rule_conway,       // 2: Cooperation (not active)
-        rule_maximum,      // 3: Aggression (not active)
-        rule_oscillate,    // 4: Stability oscillates
-        rule_average,      // 5: Mobility (not active)
-        rule_diffusion,    // 6: Resource diffuses
-        rule_average,      // 7: Age (not active)
-        rule_average,      // 8: Adaptability (not active)
+        rule_conway,      // 3: Aggression (not active)
+        rule_conway,    // 4: Stability oscillates
+        rule_conway,      // 5: Mobility (not active)
+        rule_conway,    // 6: Resource diffuses
+        rule_conway,      // 7: Age (not active)
+        rule_conway,      // 8: Adaptability (not active)
     ]);
  
     // Choose movement function
@@ -91,23 +92,24 @@ fn main() {
     println!("Configuration:");
     println!("  Grid: {}x{}", grid_width, grid_height);
     println!("  Timesteps: {}", timesteps);
-    println!("  Active traits: {:?}", 
-        active_mask.iter()
-            .enumerate()
-            .flat_map(|(r, row)| row.iter().enumerate().filter(|&(_, v)| *v).map(move |(c, _)| r * 3 + c))
-            .collect::<Vec<_>>()
-    );
+    // println!("  Active traits: {:?}", 
+    //     active_mask.iter()
+    //         .enumerate()
+    //         .flat_map(|(r, row)| row.iter().enumerate().filter(|&(_, v)| *v).map(move |(c, _)| r * 3 + c))
+    //         .collect::<Vec<_>>()
+    // );
 
     // Initial state
-    print_separator();
-    println!("INITIAL STATE (t=0)");
+    // print_separator();
+    // println!("INITIAL STATE (t=0)");
     print_active_traits(&grid, &active_mask, &trait_names);
-    print_statistics(&grid, &active_mask);
+    // print_statistics(&grid, &active_mask);
 
     // Simulation loop
-    for t in 1..=timesteps {
-        print_separator();
-        println!("TIMESTEP {}", t);
+    let start = Instant::now();
+    for _t in 1..=timesteps {
+        // print_separator();
+        // println!("TIMESTEP {}", t);
 
         // Step 1: Update all active traits
         let mut new_cells = Vec::new();
@@ -144,10 +146,21 @@ fn main() {
         grid.update_cells(moved_cells);
 
         // Print results
-        print_active_traits(&grid, &active_mask, &trait_names);
-        print_statistics(&grid, &active_mask);
+        // print_active_traits(&grid, &active_mask, &trait_names);
+        // print_statistics(&grid, &active_mask);
     }
 
     print_separator();
     println!("\nSimulation complete!");
+    
+    let elapsed = start.elapsed();
+    println!("Execution time: {:?}", elapsed);
+    println!(
+        "Performance: {:.2} timesteps/sec",
+        timesteps as f64 / elapsed.as_secs_f64()
+    );
+    println!(
+        "Cells/sec: {:.2}M",
+        (grid_width * grid_height * timesteps) as f64 / elapsed.as_secs_f64() / 1_000_000.0
+    );
 }
\ No newline at end of file
diff --git a/trait_ac/src/utils.rs b/trait_ac/src/utils.rs
index c8211f4..46adaf8 100644
--- a/trait_ac/src/utils.rs
+++ b/trait_ac/src/utils.rs
@@ -22,12 +22,13 @@ pub fn print_trait_array(grid: &Grid, trait_index: usize, trait_name: &str) {
 }
 
 /// Print all active trait arrays
-pub fn print_active_traits(grid: &Grid, active_mask: &[Vec<bool>], trait_names: &[String; 9]) {
+pub fn print_active_traits(_grid: &Grid, active_mask: &[Vec<bool>], trait_names: &[String; 9]) {
+    println!("  Active traits:");
     for mask_row in 0..3 {
         for mask_col in 0..3 {
             if active_mask[mask_row][mask_col] {
                 let trait_index = mask_row * 3 + mask_col;
-                print_trait_array(grid, trait_index, &trait_names[trait_index]);
+                println!("    {}: {} (rule: Conway)", trait_index, &trait_names[trait_index]);
             }
         }
     }
diff --git a/trait_ac_ui/src/main.rs b/trait_ac_ui/src/main.rs
index c0cd015..6fdf25f 100644
--- a/trait_ac_ui/src/main.rs
+++ b/trait_ac_ui/src/main.rs
@@ -4,6 +4,8 @@ use trait_ac::grid::Grid;
 use trait_ac::neighborhood::Neighborhood;
 use trait_ac::rules::{rule_static, rule_average, rule_conway, rule_diffusion, rule_maximum, rule_oscillate, rule_weighted_average, rule_von_neumann};
 use trait_ac::movement::{apply_movement, movement_static, movement_random, movement_gradient, movement_avoid_crowding, movement_trait_based};
+use std::time::Instant;
+use trait_ac::utils::{print_separator, print_active_traits};
 
 fn main() -> eframe::Result<()> {
     let options = eframe::NativeOptions {
@@ -112,7 +114,10 @@ struct CAApp {
     grid_density: f32,
     
     // Simulation state
+    initialized: bool,
     timestep: usize,
+    timestep_max: usize,
+    start: Instant,
     is_playing: bool,
     steps_per_second: f32,
     time_accumulator: f32,
@@ -194,27 +199,27 @@ impl ColorScheme {
 
 impl Default for CAApp {
     fn default() -> Self {
-        let grid_width = 20;
-        let grid_height = 20;
-        let grid_density = 0.33;
+        let grid_width = 3000;
+        let grid_height = 3000;
+        let grid_density = 1.0;
         let grid = Grid::new_with_density(grid_width, grid_height, grid_density);
         
         let active_mask = vec![
-            vec![true, true, false],
-            vec![false, true, false],
             vec![true, false, false],
+            vec![false, false, false],
+            vec![false, false, false],
         ];
         
         let trait_rules = vec![
-            RuleType::Diffusion,
-            RuleType::Average,
             RuleType::Conway,
-            RuleType::Maximum,
-            RuleType::Oscillate,
-            RuleType::Average,
-            RuleType::Diffusion,
-            RuleType::Average,
-            RuleType::Average,
+            RuleType::Conway,
+            RuleType::Conway,
+            RuleType::Conway,
+            RuleType::Conway,
+            RuleType::Conway,
+            RuleType::Conway,
+            RuleType::Conway,
+            RuleType::Conway,
         ];
         
         Self {
@@ -222,15 +227,18 @@ impl Default for CAApp {
             grid_width,
             grid_height,
             grid_density,
+            initialized: false,
             timestep: 0,
-            is_playing: false,
-            steps_per_second: 2.0,
+            timestep_max: 100,
+            start: Instant::now(),
+            is_playing: true,
+            steps_per_second: 10000.0,
             time_accumulator: 0.0,
             active_mask,
             trait_rules,
             movement_type: MovementType::Static,
             selected_trait: 0,
-            cell_size: 30.0,
+            cell_size: 0.397,
             show_values: false,
             color_scheme: ColorScheme::Viridis,
             base_color_no_actor: 0.1,
@@ -337,14 +345,59 @@ impl CAApp {
 
 impl eframe::App for CAApp {
     fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
-        // Handle animation
-        if self.is_playing {
+        if self.timestep >= self.timestep_max {
+            println!("Simulation completed at timestep {}. Closing app.", self.timestep);
+            print_separator();
+            self.timestep_max = 200; // to avoid printing multiple times
+
+            println!("Configuration:");
+            println!("  Grid: {}x{}", self.grid_width, self.grid_height);
+            println!("  Timesteps: {}", self.timestep);
+
+            print_active_traits(&self.grid, &self.active_mask, &self.trait_names);
+            
+            let elapsed = self.start.elapsed();
+            println!("\nExecution time: {:?}", elapsed);
+            println!(
+                "Performance: {:.2} timesteps/sec",
+                self.timestep as f64 / elapsed.as_secs_f64()
+            );
+            println!(
+                "Cells/sec: {:.2}M",
+                (self.grid_width * self.grid_height * self.timestep) as f64 / elapsed.as_secs_f64() / 1_000_000.0
+            );
+            ctx.send_viewport_cmd(egui::ViewportCommand::Close);
+            return;
+        }
+
+        if !self.initialized {
+            self.initialized = true;
+            ctx.request_repaint();
+        } else if self.is_playing {  // Handle animation
             self.time_accumulator += ctx.input(|i| i.stable_dt);
             let step_duration = 1.0 / self.steps_per_second;
             
-            while self.time_accumulator >= step_duration {
+            // Adaptive step limiting based on frame time
+            let frame_time = ctx.input(|i| i.stable_dt);
+            let target_frame_time = 1.0 / 60.0; // Target 60 FPS
+            
+            // Calculate how many steps we can afford this frame
+            let max_steps = if self.timestep == 0 || frame_time > target_frame_time * 1.5 {
+                1 // If we're lagging, only do 1 step per frame
+            } else {
+                10 // Otherwise allow up to 10 steps per frame
+            };
+            
+            let mut steps_taken = 0;
+            while self.time_accumulator >= step_duration && steps_taken < max_steps {
                 self.step_simulation();
                 self.time_accumulator -= step_duration;
+                steps_taken += 1;
+            }
+            
+            // Drop excess time if we can't keep up
+            if self.time_accumulator > step_duration * 2.0 {
+                self.time_accumulator = 0.0;
             }
             
             ctx.request_repaint();
@@ -373,7 +426,7 @@ impl eframe::App for CAApp {
                 self.randomize_grid();
             }
             
-            ui.add(egui::Slider::new(&mut self.steps_per_second, 0.1..=100.0)
+            ui.add(egui::Slider::new(&mut self.steps_per_second, 0.1..=10000.0)
                 .text("Steps/sec"));
             
             ui.label(format!("Timestep: {}", self.timestep));
@@ -383,9 +436,9 @@ impl eframe::App for CAApp {
             // Grid size
             ui.label("Grid Configuration");
             let mut changed = false;
-            changed |= ui.add(egui::Slider::new(&mut self.grid_width, 5..=250)
+            changed |= ui.add(egui::Slider::new(&mut self.grid_width, 5..=5000)
                 .text("Width")).changed();
-            changed |= ui.add(egui::Slider::new(&mut self.grid_height, 5..=250)
+            changed |= ui.add(egui::Slider::new(&mut self.grid_height, 5..=5000)
                 .text("Height")).changed();
             changed |= ui.add(egui::Slider::new(&mut self.grid_density, 0.01..=1.0)
                 .text("Density")).changed();
@@ -478,7 +531,7 @@ impl eframe::App for CAApp {
                             });
                     });
                     ui.add(egui::Slider::new(&mut self.base_color_no_actor, 0.0..=0.5).text("Empty cell base color"));
-                    ui.add(egui::Slider::new(&mut self.cell_size, 5.0..=60.0).text("Cell Size"));
+                    ui.add(egui::Slider::new(&mut self.cell_size, 0.01..=60.0).text("Cell Size"));
                     ui.checkbox(&mut self.show_values, "Show Values");
                     ui.separator();
 
