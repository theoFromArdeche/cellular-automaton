Rust Project Prompt: Modular Cellular Automata with Fingerprints (Backend Only)
Goal: Simulate a cellular automata where each cell has multiple traits (floats between 0 and 1) that evolve according to local rules and neighborhood interactions, with configurable neighborhoods and movement rules.
Specifications:
1. Cell Structure:
   * Each cell has a fixed-size fingerprint: 9 floats (values in `[0.0, 1.0]`).
   * Only a subset of traits will be active, chosen via a 3×3 boolean grid parameter.
2. Grid / World:
   * Use a 2D square grid (size configurable).
   * Each cell interacts with neighbors; neighborhood pattern is fully configurable via a boolean mask.
3. Trait Update Rules:
   * Each trait has its own local update function.
   * Rules are pluggable / replaceable for easy experimentation.
   * Only active traits (from the boolean mask) are updated at each timestep.
4. Movement Rules:
   * Each cell can move to neighboring positions according to a movement rule function.
   * Movement logic is modular, so you can change it easily later.
5. Simulation Loop:
   * At each timestep:
      1. Update all active traits for all cells.
      2. Update positions of all cells based on the movement rule.
   * Print k arrays, one per active trait: each array contains the values of that trait for all cells in row-major order.
6. Traits:
   * Floats between 0 and 1.
   * Max 9 traits (3×3 grid).
7. Extensibility / Modularity:
   * Neighborhood, local rules, and movement rules should be easy to swap or modify.
   * Keep code modular: separate modules for cells/fingerprints, rules, movement, and grid management.
8. Constraints:
   * No GUI or export required.
   * Focus purely on mathematical evolution and console output.
9. 


Project Structure

```
cellular_automata/
│
├── Cargo.toml
└── src/
    ├── main.rs          # Entry point, runs the simulation loop
    ├── lib.rs           # Optional: re-export modules if needed
    ├── grid.rs          # Manages the 2D grid, cells access, neighborhood operations
    ├── cell.rs          # Defines the Cell struct and Fingerprint
    ├── rules.rs         # Local trait update rules
    ├── movement.rs      # Movement rules for cells
    └── utils.rs         # Optional: helper functions, e.g., printing arrays

```

Module Responsibilities
1. `main.rs`
   * Sets up the simulation: grid size, active traits mask, initial values.
   * Chooses which rules and movement functions to use.
   * Runs the simulation loop and prints the arrays of active traits.
2. `cell.rs`
   * Defines the `Cell` struct:

```rust
struct Cell {
    fingerprint: [f32; 9], // 9 traits
}

```

   * Optional helper methods: get/set traits, initialize randomly, etc.
3. `grid.rs`
   * Defines the `Grid` struct (2D grid of `Cell`s).
   * Functions to access neighbors based on a configurable neighborhood mask.
   * Handles applying trait updates and movement for all cells.
4. `rules.rs`
   * Functions to update each trait locally:

```rust
fn update_confidence(cell: &Cell, neighbors: &[&Cell]) -> f32 { ... }

```

   * Use pluggable closures or function pointers to make it easy to swap rules.
5. `movement.rs`
   * Functions to move a cell based on its fingerprint and neighborhood.
   * Again, pluggable for easy experimentation.
6. `utils.rs` (optional)
   * Printing arrays of active traits in row-major order.
   * Other helper functions (e.g., random initialization).
This structure keeps different concerns separated, making it easy to:
* Change neighborhood logic (`grid.rs`)
* Swap trait rules (`rules.rs`)
* Change movement logic (`movement.rs`)
* Adjust fingerprints without touching core logic (`cell.rs`)



create the code for each .rs file